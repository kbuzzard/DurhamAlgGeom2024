import Mathlib
import DurhamAlgGeom2024.Tutorial.Â«06point5MoreHomogeneousLocalizationÂ»
section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization ğ’œ S`.

-/
open HomogeneousLocalization in
instance {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization ğ’œ S) :=
  ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization ğ’œ S) = ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {Râ‚€ S : Type}
variable [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S]
variable (ğ’œ : â„• â†’ Submodule Râ‚€ S) [GradedAlgebra ğ’œ]

instance : Algebra (ğ’œ 0) S := (SetLike.GradeZero.subalgebra ğ’œ).toAlgebra
--variable [Algebra.FiniteType (ğ’œ 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = â¨áµ¢ (ğ’œ i)` is a graded ring (graded by `â„•`) and
in particular `S` is an `ğ’œ 0`-algebra.

By assumption `S` is finitely-generated `ğ’œ 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- But we need homogeneous generators.
-- This preliminary version gives homogeneous generators
-- but allows generators in degree 0
variable [Algebra.FiniteType (ğ’œ 0) S] in
theorem FG_by_homogeneousâ‚€ : âˆƒ (Î¹â‚€ : Type) (x : Î¹â‚€ â†’ S) (_ : Fintype Î¹â‚€),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹â‚€, âˆƒ n : â„•, x i âˆˆ ğ’œ n) := by
  classical
  -- S is finitely-generated
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  -- Î¹â‚€ is pairs (s,n) such that s âˆˆ F and sâ‚™ â‰  0
  let Î¹â‚€ := Î£ (x : F), (DirectSum.decompose ğ’œ x.1).support
  -- x(s,n) is sâ‚™
  let x (i : Î¹â‚€) : S := ((DirectSum.decompose ğ’œ) i.1 i.2).1
  -- This should work
  refine âŸ¨Î¹â‚€, x, inferInstance, ?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† hF]
    apply Algebra.adjoin_le
    -- STP that if s âˆˆ F then s âˆˆ ğ’œâ‚€[tâ‚˜] for t running through F
    intro s hs
    -- Well s = âˆ‘â‚™ sâ‚™
    rw [â† DirectSum.sum_support_decompose ğ’œ s]
    -- so it suffices that âˆ€ n, sâ‚™ âˆˆ ğ’œâ‚€[tâ‚˜]
    apply sum_mem
    intro n hn
    -- so it suffices that sâ‚™ is one of the tâ‚˜
    apply Algebra.subset_adjoin
    -- but this is obvious
    use âŸ¨âŸ¨s, hsâŸ©, n, hnâŸ©
  Â· rintro âŸ¨f, nfâŸ©
    use nf
    exact ((DirectSum.decompose ğ’œ) f nf).2

variable [Algebra.FiniteType (ğ’œ 0) S] in
theorem FG_by_homogeneous : âˆƒ (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹, âˆƒ n : â„•, 0 < n âˆ§ x i âˆˆ ğ’œ n) := by
  obtain âŸ¨Î¹â‚€, x, _, h1, h2âŸ© := FG_by_homogeneousâ‚€ ğ’œ
  choose n hn using h2
  use {i : Î¹â‚€ // 0 < n i}, fun j â†¦ x j.1, inferInstance
  refine âŸ¨?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† h1]
    apply Algebra.adjoin_le
    rintro s âŸ¨i, rflâŸ©
    by_cases hi : 0 < n i
    Â· apply Algebra.subset_adjoin
      use âŸ¨i, hiâŸ©
    Â· have hi0 : n i = 0 := by omega
      exact Subalgebra.algebraMap_mem
        (Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range fun (j : {i : Î¹â‚€ // 0 < n i}) â†¦ x j)) âŸ¨x i, hi0 â–¸ hn iâŸ©
  Â· rintro âŸ¨i, hiâŸ©
    use n i, hi
    apply hn

open HomogeneousLocalization

/-

## S_{(f)} is an ğ’œâ‚€-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : â„•}
variable {f : S} (hf : f âˆˆ ğ’œ d)

--#synth Algebra (ğ’œ 0) (Away ğ’œ f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  Ï†
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- ğ’œâ‚€
                  Ï†â‚€
-/

variable (Ï†â‚€ : (ğ’œ 0) â†’+* A)
variable (Ï† : (Away ğ’œ f) â†’+* K)
variable (hcomm : (algebraMap A K).comp Ï†â‚€ = Ï†.comp (fromZeroRingHom ğ’œ _))

/-
projective_implies_proper_aux {Râ‚€ S : Type} [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S] (ğ’œ : â„• â†’ Submodule Râ‚€ S)
  [GradedAlgebra ğ’œ] [Algebra.FiniteType (â†¥(ğ’œ 0)) S] {d : â„•} {f : S} (hf : f âˆˆ ğ’œ d) {A : Type} [CommRing A] [IsDomain A]
  [ValuationRing A] {K : Type} [Field K] [Algebra A K] [IsFractionRing A K] (Ï† : Away ğ’œ f â†’+* K) (hd : 0 < d) :
  âˆƒ xâ‚€ e,
    âˆƒ (_ : 0 < e) (hâ‚€ : xâ‚€ âˆˆ ğ’œ e),
      âˆƒ Ï†', Ï†'.comp (map2 ğ’œ hâ‚€ â‹¯) = Ï† âˆ§ Set.range â‡‘(Ï†'.comp (map2 ğ’œ hf â‹¯)) âŠ† Set.range â‡‘(algebraMap A K)
-/

omit [GradedAlgebra ğ’œ] in
lemma away_zero_subsingleton : Subsingleton (Away ğ’œ 0) := by
  apply HomogeneousLocalization.subsingleton
  use 1
  simp

lemma f_ne_zero_of_away_ringHom (Ï† : Away ğ’œ f â†’+* K) : f â‰  0 := by
  rintro rfl
  have : Subsingleton (Away ğ’œ 0) :=
    away_zero_subsingleton ğ’œ
  have : Subsingleton K := RingHom.codomain_trivial Ï†
  have : Nontrivial K := CommGroupWithZero.toNontrivial
  exact false_of_nontrivial_of_subsingleton K

lemma Î¹_nonempty (hd : 0 < d) (Î¹ : Type) (x : Î¹ â†’ S)
    {f : S} (hf : f âˆˆ ğ’œ d) (Ï† : Away ğ’œ f â†’+* K)
    (hÎ¹ : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = âŠ¤) : Nonempty Î¹ := by
  suffices Â¬ IsEmpty Î¹ by exact not_isEmpty_iff.mp this
  intro hempty
  have hf0 : f â‰  0 := by exact f_ne_zero_of_away_ringHom ğ’œ Ï†
  have := Algebra.adjoin_empty (ğ’œ 0) S
  have range_empty : Set.range x = âˆ… := by
    rw [Set.eq_empty_iff_forall_not_mem]
    intro s âŸ¨i, hiâŸ©
    exact IsEmpty.false i
  rw [range_empty, this] at hÎ¹
  have hf2 : f âˆˆ (âŠ¤ : Subalgebra (ğ’œ 0) S) := by exact trivial
  rw [â† hÎ¹] at hf2
  suffices d = 0 by omega
  refine DirectSum.degree_eq_of_mem_mem ğ’œ hf ?_ hf0
  rw [Algebra.mem_bot] at hf2
  obtain âŸ¨âŸ¨g, hg1âŸ©, hgâŸ© := hf2
  rw [â† hg]
  exact hg1

instance (x : Submonoid S) : Algebra (ğ’œ 0) (HomogeneousLocalization ğ’œ x) :=
  (HomogeneousLocalization.fromZeroRingHom ğ’œ x).toAlgebra

theorem SetLike.prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R]
    [AddCommMonoid Î¹] {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    {F : Finset Îº} (hF : âˆ€ k âˆˆ F, g k âˆˆ A (i k)) : âˆ k âˆˆ F, g k âˆˆ A (âˆ‘ k âˆˆ F, i k) := by
  classical
  induction F using Finset.induction_on
  Â· simp [GradedOne.one_mem]
  Â· case insert j F' hF2 h3 =>
    rw [Finset.prod_insert hF2, Finset.sum_insert hF2]
    apply SetLike.mul_mem_graded (hF j <| Finset.mem_insert_self j F')
    apply h3
    intro k hk
    apply hF k
    exact Finset.mem_insert_of_mem hk

theorem SetLike.fintype_prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R] [AddCommMonoid Î¹]
    {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} [Fintype Îº] â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    (hF : âˆ€ k, g k âˆˆ A (i k)) : âˆ k, g k âˆˆ A (âˆ‘ k, i k) :=
  prod_mem_graded fun k _ â†¦ hF k

theorem SetLike.fintype_prod_pow_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R] [AddCommMonoid Î¹]
    {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} [Fintype Îº] â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    {v : Îº â†’ â„•}
    (hF : âˆ€ k, g k âˆˆ A (i k)) : âˆ k, g k ^ v k âˆˆ A (âˆ‘ k, v k â€¢ i k) :=
  SetLike.prod_mem_graded fun k _ â†¦ (SetLike.pow_mem_graded (v k) (hF _))


lemma algebraMap_eq' (x : Submonoid S) (a) :
    algebraMap (ğ’œ 0) (HomogeneousLocalization ğ’œ x) a =
      HomogeneousLocalization.fromZeroRingHom ğ’œ x a := rfl

open HomogeneousLocalization in
theorem Span_monomial_eq_top (f : S) (d : â„•) (hf : f âˆˆ ğ’œ d) (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹)
    (hx : Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) (dx : Î¹â†’ â„• ) (hxd : âˆ€i, x i âˆˆ ğ’œ (dx i)) :
    Submodule.span (ğ’œ 0) { mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨a * d, âŸ¨âˆ i, x i ^ ai i, hai â–¸ SetLike.fintype_prod_pow_mem_graded hxdâŸ©,
        âŸ¨f ^ a, SetLike.pow_mem_graded a hfâŸ©, by use aâŸ© |
        (a : â„•) (ai : Î¹ â†’ â„•) (hai : âˆ‘ i, ai i * dx i = a * d) } = âŠ¤ := by
  by_cases HH : Subsingleton (HomogeneousLocalization.Away ğ’œ f)
  Â· exact Subsingleton.elim _ _
  classical
  rw [â† top_le_iff]
  rintro x -
  obtain âŸ¨âŸ¨n, âŸ¨a, haâŸ©, âŸ¨b, hb'âŸ©, âŸ¨j, (rfl : _ = b)âŸ©âŸ©, rflâŸ© := mk_surjective x
  by_cases hfj : f ^ j = 0
  Â· exfalso
    apply HH
    exact HomogeneousLocalization.subsingleton _ âŸ¨_, hfjâŸ©
  have : DirectSum.decompose ğ’œ a n = (âŸ¨ a, haâŸ©  ) := by
    ext
    exact DirectSum.decompose_of_mem_same ğ’œ ha
  simp_rw [â† this]
  clear this ha
  have : a âˆˆ Submodule.span (ğ’œ 0) â†‘(Submonoid.closure (Set.range x)) := by
    rw [â† Algebra.adjoin_eq_span, hx]
    trivial
  induction this using Submodule.span_induction with
  | mem a ha' =>
    obtain âŸ¨l, hl, hl' âŸ©  := Submonoid.exists_multiset_of_mem_closure (ha')
    clear ha'
    obtain âŸ¨ai, rflâŸ© : âˆƒ l : Î¹ â†’ â„•, a = âˆ i, x i ^ l i := by
      subst hl'
      induction l using Multiset.induction with
      | empty => use 0; simp
      | cons a l ih =>
        simp only [Multiset.prod_cons, Multiset.mem_cons, Set.mem_range,
          forall_eq_or_imp] at hl
        obtain âŸ¨âŸ¨a, rflâŸ©, hâŸ© := hl
        obtain âŸ¨l', hl''âŸ© := ih h
        simp only [Multiset.prod_cons, hl'']
        use l' + (if Â· = a then 1 else 0)
        simp only [Pi.add_apply, pow_add, pow_ite, pow_one, pow_zero, mul_one]
        rw [Finset.prod_mul_distrib]
        simp only [Finset.prod_ite_eq', Finset.mem_univ, â†“reduceIte]
        exact mul_comm _ _
    clear hl hl' l
    by_cases H : âˆ‘ i, ai i * dx i = n
    Â· apply Submodule.subset_span
      simp
      use j
      use ai
      constructor
      Â· ext
        simp
        congr
        symm
        apply DirectSum.decompose_of_mem_same
        rw [â† H]
        exact SetLike.fintype_prod_pow_mem_graded hxd
      Â· trans n
        Â· exact H
        Â· apply DirectSum.degree_eq_of_mem_mem ğ’œ hb' ?_ hfj
          exact SetLike.pow_mem_graded j hf
    Â· convert zero_mem _
      ext
      simp
      have :( ((DirectSum.decompose ğ’œ) (âˆ i : Î¹, x i ^ ai i)) n ).1= 0 := by
        apply DirectSum.decompose_of_mem_ne _ _ H
        exact SetLike.fintype_prod_pow_mem_graded hxd
      rw [this, Localization.mk_zero]
      infer_instance
      infer_instance
  | zero =>
      convert zero_mem _
      Â· ext ; simp ; rw [Localization.mk_zero]
      infer_instance
      infer_instance

  | add s t hs ht hs' ht'  =>
    convert add_mem hs' ht'
    ext ; simp
    rw [â† Localization.add_mk_self]

  | smul r x hx hx' =>
    convert Submodule.smul_mem _ r hx'
    ext
    simp only [val_mk, Algebra.smul_def, val_mul, algebraMap_eq',
      fromZeroRingHom, DirectSum.decompose_mul, RingHom.coe_mk,
      MonoidHom.coe_mk, OneHom.coe_mk, val_mk,
      SetLike.GradeZero.coe_one, Localization.mk_mul,
      Submonoid.mk_mul_mk, one_mul]
    congr
    erw [DirectSum.decompose_coe]
    clear hx hx'
    induction x using DirectSum.Decomposition.inductionOn ğ’œ with
    | h_zero => simp
    | @h_homogeneous i m =>
      simp [DirectSum.of_mul_of]
      by_cases H : i = n
      Â· subst H
        simp only [DirectSum.of_eq_same]
        convert congr($(DirectSum.of_eq_same (Î² := fun i â†¦ ğ’œ i) (0 + i)
          (GradedMonoid.GMul.mul (A := (ğ’œ Â·)) r m)).1) <;> simp
      Â· rw [DirectSum.of_eq_of_ne, DirectSum.of_eq_of_ne]
        Â· simp
        Â· exact H
        Â· simpa
    | h_add =>
      simp_all [mul_add]

theorem Localization.mk_prod {R : Type*} [CommRing R] {S : Submonoid R} {Î¹} (t : Finset Î¹)
    (f : Î¹ â†’ R) (s : Î¹ â†’ S) :
    âˆ i in t, Localization.mk (f i) (s i) = Localization.mk (âˆ i in t, f i) (âˆ i in t, s i) := by
  classical
  induction t using Finset.induction_on
  Â· simp [Localization.mk_one]
  Â· simp [Finset.prod_insert â€¹_â€º, *, Localization.mk_mul]

theorem projective_implies_proper_aux
    (Î¹ : Type) [Fintype Î¹] (x : Î¹ â†’ S)
    (h2 : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = (âŠ¤ : Subalgebra (ğ’œ 0) S))
    (j : Î¹)
    (Ï† : Away ğ’œ (x j) â†’+* K)
    (d : Î¹ â†’ â„•)
    (hdi : âˆ€ i, 0 < d i)
    (hxdi : âˆ€ i, x i âˆˆ ğ’œ (d i)) :
    âˆƒ (xâ‚€ : S) (e : â„•) (he : 0 < e)
      (hâ‚€ : xâ‚€ âˆˆ ğ’œ e)
      (Ï†' : Away ğ’œ ((x j) * xâ‚€) â†’+* K),
      (Ï†'.comp (map2 ğ’œ hâ‚€ rfl) = Ï†) âˆ§
      Set.range (Ï†'.comp (map2 ğ’œ (hxdi j) (mul_comm (x j) xâ‚€))) âŠ† Set.range (algebraMap A K) := by
  classical
  let Ïˆ: (i : Î¹) â†’ ValuationRing.ValueGroup A K :=
    fun i â†¦ ValuationRing.valuation A K <| (Ï† (mk {
      deg := (d j) * d i
      num := âŸ¨x i ^ d j, SetLike.pow_mem_graded (d j) (hxdi i) âŸ©
      den := âŸ¨(x j)^(d i) , mul_comm (d j) (d i) â–¸ SetLike.pow_mem_graded (d i) ( hxdi j)âŸ©
      den_mem := âŸ¨_, rflâŸ©
    }))^ âˆ k in Finset.univ.erase i, d k
  have hÎ¹nonempty : Nonempty Î¹ := by exact Î¹_nonempty ğ’œ (hdi j) Î¹ x (hxdi j) Ï† h2
  have foo : (Finset.image Ïˆ Finset.univ).Nonempty := by rwa [Finset.image_nonempty, Finset.univ_nonempty_iff]
  set Kmax := Finset.max' (Finset.image Ïˆ Finset.univ) foo
  have : Kmax âˆˆ _ := Finset.max'_mem (Finset.image Ïˆ Finset.univ) foo
  simp only [Finset.mem_image, Finset.mem_univ, true_and] at this
  obtain âŸ¨i0, hi1âŸ© := this
  have hi0 : âˆ€ (j : Î¹), Ïˆ j â‰¤ Ïˆ i0 := by
    intro j
    rw [hi1]
    exact Finset.le_max' (Finset.image Ïˆ Finset.univ) (Ïˆ j) (by simp)
  use x i0, d i0, hdi i0, hxdi i0
  have hKmax : Kmax â‰  0 := by
    intro hKmax
    unfold Kmax at hKmax
    have : âˆ€ i : Î¹, Ïˆ i â‰¤ 0 := by
      intro i
      rw [â† hKmax]
      apply Finset.le_max'
      simp
    have this : âˆ€ i, Ïˆ i = 0 := by
      intro i
      specialize this i
      exact le_zero_iff.mp this
    unfold Ïˆ at this
    simp only [map_pow, pow_eq_zero_iff', map_eq_zero, ne_eq] at this
    specialize this j
    suffices Ï† 1 = 0 by
      simp only [map_one, one_ne_zero] at this
    convert this.1
    ext
    simp only [val_one, val_mk]
    symm
    convert Localization.mk_self _
    rfl
  have hKmax : 0 < Kmax := zero_lt_iff.mpr hKmax
  have foo := HomogeneousLocalization.Away.isLocalization_mul ğ’œ (x j) (x i0) (d j) (d i0)
    (hxdi j) (hxdi i0) (hdi _).ne' (hdi _).ne'
  letI := awayAlgebra ğ’œ (x j) (x i0) (d i0) (hxdi i0)
  have foounit : IsUnit (Ï† (mk { deg := d j * d i0,
                                 num := âŸ¨x i0 ^ d j, SetLike.pow_mem_graded (d j) (hxdi i0)âŸ©,
                                 den := âŸ¨x j ^ d i0, mul_comm (d j) (d i0) â–¸ SetLike.pow_mem_graded (d i0) ( hxdi j)âŸ©,
                                 den_mem := âŸ¨d i0, rflâŸ©})) := by
    unfold Ïˆ at hi1
    apply Ne.isUnit
    intro rid
    rw [rid] at hi1
    simp only [map_pow, map_zero] at hi1
    rw [zero_pow] at hi1
    Â· exact hKmax.ne' hi1.symm
    simp only [ne_eq, Finset.prod_eq_zero_iff, Finset.mem_erase, Finset.mem_univ, and_true,
      not_exists, not_and]
    intro k _ hk
    exact hdi k |>.ne' hk
  let Ï†' := @IsLocalization.Away.lift _ _ _ _ _ _ _ _ foo Ï† foounit
  have hÏ†' : âˆ€ s, Ï†' _ = _ := @IsLocalization.Away.AwayMap.lift_eq _ _ _ _ _ _ _ _ foo _ foounit
  use Ï†'
  use IsLocalization.Away.AwayMap.lift_comp ..
  rintro _ âŸ¨sx, rflâŸ©
  rw [Set.mem_range, â† ValuationRing.mem_integer_iff]
  rw [Valuation.mem_integer_iff]
  have := Span_monomial_eq_top ğ’œ (x i0) (d i0) (hxdi i0) Î¹
    x inferInstance h2 d hxdi
  letI inst1 : Algebra (ğ’œ 0) (Away ğ’œ (x i0)) := inferInstance
  letI inst2 : Module (ğ’œ 0) (Away ğ’œ (x i0)) := Algebra.toModule
  have foo2 : sx âˆˆ (âŠ¤ : Submodule (ğ’œ 0) (Away ğ’œ (x i0))) := Submodule.mem_top
  rw [â† this] at foo2
  induction foo2 using Submodule.span_induction with
  | mem x1 h =>
    obtain âŸ¨a, ai, hai, rflâŸ© := h
    suffices (ValuationRing.valuation A K)
        (Ï† (mk {deg := a * d i0 * d j,
                num := âŸ¨(âˆ i : Î¹, x i ^ ai i) * (x i0) ^ (a * (d j - 1)), by
                  have this1 := SetLike.fintype_prod_pow_mem_graded (v := ai) (i := d) hxdi
                  have this2 := SetLike.pow_mem_graded (a * (d j - 1)) (hxdi i0)
                  have := SetLike.mul_mem_graded this1 this2
                  convert this using 2
                  simp
                  rw [hai]
                  have hdj : (d j â‰  0) := (hdi j).ne'
                  revert hdj
                  cases (d j)
                  Â· simp
                  Â· intro _
                    simp
                    ring
                âŸ©,
                den := âŸ¨(x j) ^ (a * d i0), sorryâŸ©,
                den_mem := âŸ¨_, rflâŸ©}) /
          (Ï† (mk {deg := d j * d i0,
                  num := âŸ¨(x i0) ^ d j, sorryâŸ©,
                  den := âŸ¨(x j) ^ (d i0), sorryâŸ©,
                  den_mem := sorry})) ^ a) â‰¤ 1 by
      convert this
      rw [eq_div_iff <| by rw [â†isUnit_iff_ne_zero]; exact IsUnit.pow _ foounit]
      rw [â† hÏ†', â† hÏ†']
      simp only [RingHom.coe_comp, Function.comp_apply]
      rw [â† map_pow, â† map_mul]
      congr
      -- Kevin is working on this
      sorry
    rw [map_divâ‚€]
    rw [div_le_iffâ‚€ sorry, one_mul]
    rw [â† pow_le_pow_iff_leftâ‚€ (n := d j * âˆ i, d i) sorry sorry sorry]
    convert_to (âˆ i, Ïˆ i ^ (d i * ai i)) * Ïˆ i0 ^ (d i0 * a * (d j - 1)) â‰¤ _
    Â· simp only [Ïˆ, â† map_pow, â† map_prod, â† map_mul]
      congr 2
      apply (show Function.Injective (algebraMap (Away ğ’œ (x j)) (Localization.Away (x j)))
        from val_injective _)
      simp only [map_pow, map_prod, map_mul]
      simp only [HomogeneousLocalization.algebraMap_apply, val_mk,
        Localization.mk_pow, Localization.mk_prod, Localization.mk_mul]
      rw [Localization.mk_eq_mk_iff, Localization.r_iff_exists]
      use 1
      simp only [OneMemClass.coe_one, SubmonoidClass.mk_pow, â† pow_mul, Submonoid.coe_mul,
        SubmonoidClass.coe_finset_prod, one_mul]
      simp_rw [Finset.mul_prod_erase Finset.univ d (h := Finset.mem_univ _),
        mul_assoc, â† mul_assoc (Finset.prod ..),
        Finset.prod_erase_mul Finset.univ d (h := Finset.mem_univ _)]
      rw [Finset.prod_pow_eq_pow_sum, â† pow_add, mul_pow, â† Finset.prod_pow]
      simp_rw [â† pow_mul]
      congr 3
      Â· simp_rw [mul_assoc, â† Finset.mul_sum, mul_comm (d _) (ai _), hai]
        have : d j â‰  0 := (hdi j).ne'
        revert this
        cases d j
        Â· simp
        Â· intro _
          simp
          ring
      Â· ext i
        congr 1
        ring
      Â· ring
    Â· trans (âˆ i : Î¹, Ïˆ i0 ^ (d i * ai i)) * Ïˆ i0 ^ (d i0 * a * (d j - 1))
      Â· gcongr
        Â· exact zero_le'
        Â· exact hi0 _
      Â· rw [Finset.prod_pow_eq_pow_sum, â† pow_add]
        convert_to (Ïˆ i0) ^ (d i0 * a * d j) â‰¤ _
        Â· congr 1
          simp_rw [mul_comm (d _) (ai _), hai]
          have : d j â‰  0 := (hdi j).ne'
          revert this
          cases d j
          Â· simp
          Â· intro _
            simp
            ring
        Â· apply le_of_eq
          simp only [Ïˆ, â† map_pow, â† map_prod, â† map_mul]
          congr 2
          rw [â† pow_mul, mul_assoc, â† mul_assoc,
            Finset.prod_erase_mul Finset.univ d (h := Finset.mem_univ _),
            mul_left_comm, pow_mul]
          congr 1
          rw [mul_comm]
  | zero => simp
  | add x y hx hy hhx hhy =>
    simp only [RingHom.coe_comp, Function.comp_apply, map_add, ge_iff_le]
    transitivity
    refine Valuation.map_add (ValuationRing.valuation A K) _ _
    rw [sup_le_iff]
    exact âŸ¨hhx, hhyâŸ©
  | smul a x hx _ => sorry

end statement
