import Mathlib
import DurhamAlgGeom2024.Tutorial.Â«06SeparatedÂ»
section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization ğ’œ S`.

-/
open HomogeneousLocalization in
instance {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization ğ’œ S) :=
  ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization ğ’œ S) = ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {Râ‚€ S : Type}
variable [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S]
variable (ğ’œ : â„• â†’ Submodule Râ‚€ S) [GradedAlgebra ğ’œ]

instance : Algebra (ğ’œ 0) S := (SetLike.GradeZero.subalgebra ğ’œ).toAlgebra
variable [Algebra.FiniteType (ğ’œ 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = â¨áµ¢ (ğ’œ i)` is a graded ring (graded by `â„•`) and
in particular `S` is an `ğ’œ 0`-algebra.

By assumption `S` is finitely-generated `ğ’œ 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- S is finitely-generated over ğ’œ 0
example : âˆƒ (F : Set S),
    (F.Finite) âˆ§ (Algebra.adjoin (ğ’œ 0) F = âŠ¤) := by
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  exact âŸ¨F, F.finite_toSet, hFâŸ©

-- But we need homogeneous generators.
-- This preliminary version gives homogeneous generators
-- but allows generators in degree 0
theorem FG_by_homogeneousâ‚€ : âˆƒ (Î¹â‚€ : Type) (x : Î¹â‚€ â†’ S) (_ : Fintype Î¹â‚€),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹â‚€, âˆƒ n : â„•, x i âˆˆ ğ’œ n) := by
  classical
  -- S is finitely-generated
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  -- Î¹â‚€ is pairs (s,n) such that s âˆˆ F and sâ‚™ â‰  0
  let Î¹â‚€ := Î£ (x : F), (DirectSum.decompose ğ’œ x.1).support
  -- x(s,n) is sâ‚™
  let x (i : Î¹â‚€) : S := ((DirectSum.decompose ğ’œ) i.1 i.2).1
  -- This should work
  refine âŸ¨Î¹â‚€, x, inferInstance, ?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† hF]
    apply Algebra.adjoin_le
    -- STP that if s âˆˆ F then s âˆˆ ğ’œâ‚€[tâ‚˜] for t running through F
    intro s hs
    -- Well s = âˆ‘â‚™ sâ‚™
    rw [â† DirectSum.sum_support_decompose ğ’œ s]
    -- so it suffices that âˆ€ n, sâ‚™ âˆˆ ğ’œâ‚€[tâ‚˜]
    apply sum_mem
    intro n hn
    -- so it suffices that sâ‚™ is one of the tâ‚˜
    apply Algebra.subset_adjoin
    -- but this is obvious
    use âŸ¨âŸ¨s, hsâŸ©, n, hnâŸ©
  Â· rintro âŸ¨f, nfâŸ©
    use nf
    exact ((DirectSum.decompose ğ’œ) f nf).2

theorem FG_by_homogeneous : âˆƒ (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹, âˆƒ n : â„•, 0 < n âˆ§ x i âˆˆ ğ’œ n) := by
  obtain âŸ¨Î¹â‚€, x, _, h1, h2âŸ© := FG_by_homogeneousâ‚€ ğ’œ
  choose n hn using h2
  use {i : Î¹â‚€ // 0 < n i}
  use fun j â†¦ x j.1
  use inferInstance
  refine âŸ¨?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† h1]
    apply Algebra.adjoin_le
    rintro s âŸ¨i, rflâŸ©
    by_cases hi : 0 < n i
    Â· apply Algebra.subset_adjoin
      use âŸ¨i, hiâŸ©
    Â· have hi0 : n i = 0 := by omega
      exact Subalgebra.algebraMap_mem
        (Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range fun (j : {i : Î¹â‚€ // 0 < n i}) â†¦ x j)) âŸ¨x i, hi0 â–¸ hn iâŸ©
  Â· rintro âŸ¨i, hiâŸ©
    use n i, hi
    apply hn

open HomogeneousLocalization

/-

## S_{(f)} is an ğ’œâ‚€-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : â„•}
variable {f : S} (hf : f âˆˆ ğ’œ d)

--#synth Algebra (ğ’œ 0) (Away ğ’œ f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  Ï†
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- ğ’œâ‚€
                  Ï†â‚€
-/

variable (Ï†â‚€ : (ğ’œ 0) â†’+* A)
variable (Ï† : (Away ğ’œ f) â†’+* K)
variable (hcomm : (algebraMap A K).comp Ï†â‚€ = Ï†.comp (fromZeroRingHom ğ’œ _))

theorem projective_implies_proper_aux : âˆƒ (xâ‚€ : S) (e : â„•) (he : 0 < e)
    (hâ‚€ : xâ‚€ âˆˆ ğ’œ e)
    (Ï†' : Away ğ’œ (f * xâ‚€) â†’+* K),
    (Ï†'.comp (map2 ğ’œ hâ‚€ rfl) = Ï†) âˆ§
    Set.range (Ï†'.comp (map2 ğ’œ hf (mul_comm f xâ‚€))) âŠ† Set.range (algebraMap A K) := by
  classical
  obtain âŸ¨Î¹, x, h1, h2, h3âŸ©:= FG_by_homogeneous ğ’œ
  choose di hdi hxdi using h3
  let Ïˆ: (i : Î¹) â†’ ValuationRing.ValueGroup A K :=
    fun i â†¦ ValuationRing.valuation A K <| (Ï† (mk {
      deg := d * di i
      num := âŸ¨x i ^d, SetLike.pow_mem_graded d (hxdi i) âŸ©
      den := âŸ¨f^(di i) , mul_comm d (di i) â–¸ SetLike.pow_mem_graded (di i) ( hf)âŸ©
      den_mem := âŸ¨_, rflâŸ©
    }))^ âˆ j in Finset.univ.erase i, di j
  cases isEmpty_or_nonempty Î¹
  Â· sorry
  Â· have foo : (Finset.image Ïˆ Finset.univ).Nonempty := by rwa [Finset.image_nonempty, Finset.univ_nonempty_iff]
    set Kmax := Finset.max' (Finset.image Ïˆ Finset.univ) foo
    have : Kmax âˆˆ _ := Finset.max'_mem (Finset.image Ïˆ Finset.univ) foo
    simp only [Finset.mem_image, Finset.mem_univ, true_and] at this
    obtain âŸ¨i0, hi0âŸ© := this
    have hi0 : âˆ€ (j : Î¹), Ïˆ j â‰¤ Ïˆ i0 := by
      intro j
      rw [hi0]
      exact Finset.le_max' (Finset.image Ïˆ Finset.univ) (Ïˆ j) (by simp)
    use x i0
    use di i0
    use hdi i0
    use hxdi i0
    sorry

end statement
