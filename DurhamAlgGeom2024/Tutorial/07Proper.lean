import Mathlib
import DurhamAlgGeom2024.Tutorial.Â«06point5MoreHomogeneousLocalizationÂ»
section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization ğ’œ S`.

-/
open HomogeneousLocalization in
instance {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization ğ’œ S) :=
  ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization ğ’œ S) = ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {Râ‚€ S : Type}
variable [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S]
variable (ğ’œ : â„• â†’ Submodule Râ‚€ S) [GradedAlgebra ğ’œ]

instance : Algebra (ğ’œ 0) S := (SetLike.GradeZero.subalgebra ğ’œ).toAlgebra
--variable [Algebra.FiniteType (ğ’œ 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = â¨áµ¢ (ğ’œ i)` is a graded ring (graded by `â„•`) and
in particular `S` is an `ğ’œ 0`-algebra.

By assumption `S` is finitely-generated `ğ’œ 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- But we need homogeneous generators.
-- This preliminary version gives homogeneous generators
-- but allows generators in degree 0
variable [Algebra.FiniteType (ğ’œ 0) S] in
theorem FG_by_homogeneousâ‚€ : âˆƒ (Î¹â‚€ : Type) (x : Î¹â‚€ â†’ S) (_ : Fintype Î¹â‚€),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹â‚€, âˆƒ n : â„•, x i âˆˆ ğ’œ n) := by
  classical
  -- S is finitely-generated
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  -- Î¹â‚€ is pairs (s,n) such that s âˆˆ F and sâ‚™ â‰  0
  let Î¹â‚€ := Î£ (x : F), (DirectSum.decompose ğ’œ x.1).support
  -- x(s,n) is sâ‚™
  let x (i : Î¹â‚€) : S := ((DirectSum.decompose ğ’œ) i.1 i.2).1
  -- This should work
  refine âŸ¨Î¹â‚€, x, inferInstance, ?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† hF]
    apply Algebra.adjoin_le
    -- STP that if s âˆˆ F then s âˆˆ ğ’œâ‚€[tâ‚˜] for t running through F
    intro s hs
    -- Well s = âˆ‘â‚™ sâ‚™
    rw [â† DirectSum.sum_support_decompose ğ’œ s]
    -- so it suffices that âˆ€ n, sâ‚™ âˆˆ ğ’œâ‚€[tâ‚˜]
    apply sum_mem
    intro n hn
    -- so it suffices that sâ‚™ is one of the tâ‚˜
    apply Algebra.subset_adjoin
    -- but this is obvious
    use âŸ¨âŸ¨s, hsâŸ©, n, hnâŸ©
  Â· rintro âŸ¨f, nfâŸ©
    use nf
    exact ((DirectSum.decompose ğ’œ) f nf).2

variable [Algebra.FiniteType (ğ’œ 0) S] in
theorem FG_by_homogeneous : âˆƒ (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹, âˆƒ n : â„•, 0 < n âˆ§ x i âˆˆ ğ’œ n) := by
  obtain âŸ¨Î¹â‚€, x, _, h1, h2âŸ© := FG_by_homogeneousâ‚€ ğ’œ
  choose n hn using h2
  use {i : Î¹â‚€ // 0 < n i}, fun j â†¦ x j.1, inferInstance
  refine âŸ¨?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† h1]
    apply Algebra.adjoin_le
    rintro s âŸ¨i, rflâŸ©
    by_cases hi : 0 < n i
    Â· apply Algebra.subset_adjoin
      use âŸ¨i, hiâŸ©
    Â· have hi0 : n i = 0 := by omega
      exact Subalgebra.algebraMap_mem
        (Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range fun (j : {i : Î¹â‚€ // 0 < n i}) â†¦ x j)) âŸ¨x i, hi0 â–¸ hn iâŸ©
  Â· rintro âŸ¨i, hiâŸ©
    use n i, hi
    apply hn

open HomogeneousLocalization

/-

## S_{(f)} is an ğ’œâ‚€-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : â„•}
variable {f : S} (hf : f âˆˆ ğ’œ d)

--#synth Algebra (ğ’œ 0) (Away ğ’œ f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  Ï†
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- ğ’œâ‚€
                  Ï†â‚€
-/

variable (Ï†â‚€ : (ğ’œ 0) â†’+* A)
variable (Ï† : (Away ğ’œ f) â†’+* K)
variable (hcomm : (algebraMap A K).comp Ï†â‚€ = Ï†.comp (fromZeroRingHom ğ’œ _))

/-
projective_implies_proper_aux {Râ‚€ S : Type} [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S] (ğ’œ : â„• â†’ Submodule Râ‚€ S)
  [GradedAlgebra ğ’œ] [Algebra.FiniteType (â†¥(ğ’œ 0)) S] {d : â„•} {f : S} (hf : f âˆˆ ğ’œ d) {A : Type} [CommRing A] [IsDomain A]
  [ValuationRing A] {K : Type} [Field K] [Algebra A K] [IsFractionRing A K] (Ï† : Away ğ’œ f â†’+* K) (hd : 0 < d) :
  âˆƒ xâ‚€ e,
    âˆƒ (_ : 0 < e) (hâ‚€ : xâ‚€ âˆˆ ğ’œ e),
      âˆƒ Ï†', Ï†'.comp (map2 ğ’œ hâ‚€ â‹¯) = Ï† âˆ§ Set.range â‡‘(Ï†'.comp (map2 ğ’œ hf â‹¯)) âŠ† Set.range â‡‘(algebraMap A K)
-/

omit [GradedAlgebra ğ’œ] in
lemma away_zero_subsingleton : Subsingleton (Away ğ’œ 0) := by
  apply HomogeneousLocalization.subsingleton
  use 1
  simp

lemma f_ne_zero_of_away_ringHom (Ï† : Away ğ’œ f â†’+* K) : f â‰  0 := by
  rintro rfl
  have : Subsingleton (Away ğ’œ 0) :=
    away_zero_subsingleton ğ’œ
  have : Subsingleton K := RingHom.codomain_trivial Ï†
  have : Nontrivial K := CommGroupWithZero.toNontrivial
  exact false_of_nontrivial_of_subsingleton K

lemma Î¹_nonempty (hd : 0 < d) (Î¹ : Type) (x : Î¹ â†’ S)
    {f : S} (hf : f âˆˆ ğ’œ d) (Ï† : Away ğ’œ f â†’+* K)
    (hÎ¹ : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = âŠ¤) : Nonempty Î¹ := by
  suffices Â¬ IsEmpty Î¹ by exact not_isEmpty_iff.mp this
  intro hempty
  have hf0 : f â‰  0 := by exact f_ne_zero_of_away_ringHom ğ’œ Ï†
  have := Algebra.adjoin_empty (ğ’œ 0) S
  have range_empty : Set.range x = âˆ… := by
    rw [Set.eq_empty_iff_forall_not_mem]
    intro s âŸ¨i, hiâŸ©
    exact IsEmpty.false i
  rw [range_empty, this] at hÎ¹
  have hf2 : f âˆˆ (âŠ¤ : Subalgebra (ğ’œ 0) S) := by exact trivial
  rw [â† hÎ¹] at hf2
  suffices d = 0 by omega
  refine DirectSum.degree_eq_of_mem_mem ğ’œ hf ?_ hf0
  rw [Algebra.mem_bot] at hf2
  obtain âŸ¨âŸ¨g, hg1âŸ©, hgâŸ© := hf2
  rw [â† hg]
  exact hg1

instance (x : Submonoid S) : Algebra (ğ’œ 0) (HomogeneousLocalization ğ’œ x) :=
  (HomogeneousLocalization.fromZeroRingHom ğ’œ x).toAlgebra

theorem SetLike.prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R]
    [AddCommMonoid Î¹] {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    {F : Finset Îº} (hF : âˆ€ k âˆˆ F, g k âˆˆ A (i k)) : âˆ k âˆˆ F, g k âˆˆ A (âˆ‘ k âˆˆ F, i k) := by
  classical
  induction F using Finset.induction_on
  Â· simp [GradedOne.one_mem]
  Â· case insert j F' hF2 h3 =>
    rw [Finset.prod_insert hF2, Finset.sum_insert hF2]
    apply SetLike.mul_mem_graded (hF j <| Finset.mem_insert_self j F')
    apply h3
    intro k hk
    apply hF k
    exact Finset.mem_insert_of_mem hk

theorem SetLike.fintype_prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R] [AddCommMonoid Î¹]
    {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} [Fintype Îº] â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    (hF : âˆ€ k, g k âˆˆ A (i k)) : âˆ k, g k âˆˆ A (âˆ‘ k, i k) :=
  prod_mem_graded fun k _ â†¦ hF k

theorem SetLike.fintype_prod_pow_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R] [AddCommMonoid Î¹]
    {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} [Fintype Îº] â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    {v : Îº â†’ â„•}
    (hF : âˆ€ k, g k âˆˆ A (i k)) : âˆ k, g k ^ v k âˆˆ A (âˆ‘ k, v k â€¢ i k) :=
  SetLike.prod_mem_graded fun k _ â†¦ (SetLike.pow_mem_graded (v k) (hF _))


lemma algebraMap_eq' (x : Submonoid S) (a) :
    algebraMap (ğ’œ 0) (HomogeneousLocalization ğ’œ x) a =
      HomogeneousLocalization.fromZeroRingHom ğ’œ x a := rfl

theorem Submonoid.exists_finsupp_of_mem_closure_range {M : Type*} [CommMonoid M] {Î¹ : Type*}
    (f : Î¹ â†’ M) {x} (hx : x âˆˆ Submonoid.closure (Set.range f)) :
    âˆƒ a : Î¹ â†’â‚€ â„•, x = a.prod (f Â· ^ Â·) := by
  classical
  induction hx using Submonoid.closure_induction with
  | mem x h => obtain âŸ¨i, rflâŸ© := h; exact âŸ¨Finsupp.single i 1, by simpâŸ©
  | one => use 0; simp
  | mul x y hx hy hx' hy' =>
    obtain âŸ¨âŸ¨v, rflâŸ©, w, rflâŸ© := And.intro hx' hy'
    use v + w
    rw [Finsupp.prod_add_index]
    Â· simp
    Â· simp [pow_add]

theorem Submonoid.exists_of_mem_closure_range {M : Type*} [CommMonoid M] {Î¹ : Type*} [Fintype Î¹]
    (f : Î¹ â†’ M) {x} (hx : x âˆˆ Submonoid.closure (Set.range f)) :
    âˆƒ a : Î¹ â†’ â„•, x = âˆ i, f i ^ a i := by
  obtain âŸ¨a, rflâŸ© := Submonoid.exists_finsupp_of_mem_closure_range f hx
  exact âŸ¨a, by simpâŸ©

open HomogeneousLocalization in
theorem HomogeneousLocalization.Away.span_monomial_eq_top (f : S) (d : â„•) (hf : f âˆˆ ğ’œ d)
    (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹)
    (hx : Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) (dx : Î¹ â†’ â„• ) (hxd : âˆ€i, x i âˆˆ ğ’œ (dx i)) :
    Submodule.span (ğ’œ 0) { mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨a * d, âŸ¨âˆ i, x i ^ ai i, hai â–¸ SetLike.fintype_prod_pow_mem_graded hxdâŸ©,
        âŸ¨f ^ a, SetLike.pow_mem_graded a hfâŸ©, by use aâŸ© |
        (a : â„•) (ai : Î¹ â†’ â„•) (hai : âˆ‘ i, ai i * dx i = a * d) } = âŠ¤ := by
  by_cases HH : Subsingleton (HomogeneousLocalization.Away ğ’œ f)
  Â· exact Subsingleton.elim _ _
  classical
  rw [â† top_le_iff]
  rintro x -
  obtain âŸ¨âŸ¨n, âŸ¨a, haâŸ©, âŸ¨b, hb'âŸ©, âŸ¨j, (rfl : _ = b)âŸ©âŸ©, rflâŸ© := mk_surjective x
  by_cases hfj : f ^ j = 0
  Â· exact (HH (HomogeneousLocalization.subsingleton _ âŸ¨_, hfjâŸ©)).elim
  have : DirectSum.decompose ğ’œ a n = âŸ¨a, haâŸ© := Subtype.ext (DirectSum.decompose_of_mem_same ğ’œ ha)
  simp_rw [â† this]
  clear this ha
  have : a âˆˆ Submodule.span (ğ’œ 0) (Submonoid.closure (Set.range x)) := by
    rw [â† Algebra.adjoin_eq_span, hx]
    trivial
  induction this using Submodule.span_induction with
  | mem a ha' =>
    obtain âŸ¨ai, rflâŸ© := Submonoid.exists_of_mem_closure_range _ ha'
    clear ha'
    by_cases H : âˆ‘ i, ai i * dx i = n
    Â· apply Submodule.subset_span
      refine âŸ¨j, ai, H.trans ?_, ?_âŸ©
      Â· exact DirectSum.degree_eq_of_mem_mem ğ’œ hb'
          (SetLike.pow_mem_graded j hf) hfj
      Â· ext
        simp only [val_mk]
        congr
        refine (DirectSum.decompose_of_mem_same _ ?_).symm
        exact H â–¸ SetLike.fintype_prod_pow_mem_graded hxd
    Â· convert zero_mem (Submodule.span (ğ’œ 0) _)
      ext
      have : (DirectSum.decompose ğ’œ (âˆ i : Î¹, x i ^ ai i) n).1= 0 := by
        refine DirectSum.decompose_of_mem_ne _ ?_ H
        exact SetLike.fintype_prod_pow_mem_graded hxd
      simp [this, Localization.mk_zero]
  | zero =>
      convert zero_mem (Submodule.span (ğ’œ 0) _)
      ext; simp [Localization.mk_zero]
  | add s t hs ht hs' ht'  =>
    convert add_mem hs' ht'
    ext; simp [â† Localization.add_mk_self]
  | smul r x hx hx' =>
    convert Submodule.smul_mem _ r hx'
    ext
    simp only [val_mk, Algebra.smul_def, val_mul, algebraMap_eq',
      fromZeroRingHom, DirectSum.decompose_mul, RingHom.coe_mk,
      MonoidHom.coe_mk, OneHom.coe_mk, val_mk,
      SetLike.GradeZero.coe_one, Localization.mk_mul,
      Submonoid.mk_mul_mk, one_mul]
    congr
    erw [DirectSum.decompose_coe]
    clear hx hx'
    induction x using DirectSum.Decomposition.inductionOn ğ’œ with
    | h_zero => simp
    | @h_homogeneous i m =>
      simp [DirectSum.of_mul_of]
      by_cases H : i = n
      Â· subst H
        simp only [DirectSum.of_eq_same]
        convert congr($(DirectSum.of_eq_same (Î² := fun i â†¦ ğ’œ i) (0 + i)
          (GradedMonoid.GMul.mul (A := (ğ’œ Â·)) r m)).1) <;> simp
      Â· rw [DirectSum.of_eq_of_ne, DirectSum.of_eq_of_ne]
        Â· simp
        Â· exact H
        Â· simpa
    | h_add =>
      simp_all [mul_add]

theorem Localization.mk_prod {R : Type*} [CommRing R] {S : Submonoid R} {Î¹} (t : Finset Î¹)
    (f : Î¹ â†’ R) (s : Î¹ â†’ S) :
    âˆ i in t, Localization.mk (f i) (s i) = Localization.mk (âˆ i in t, f i) (âˆ i in t, s i) := by
  classical
  induction t using Finset.induction_on
  Â· simp [Localization.mk_one]
  Â· simp [Finset.prod_insert â€¹_â€º, *, Localization.mk_mul]

open HomogeneousLocalization in
theorem HomogeneousLocalization.Away.adjoin_monomial_eq_top (f : S) (d : â„•) (hf : f âˆˆ ğ’œ d) (hd : 0 < d)
    (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹)
    (hx : Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) (dx : Î¹ â†’ â„• ) (hxd : âˆ€i, x i âˆˆ ğ’œ (dx i)) :
    Algebra.adjoin (ğ’œ 0) { mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨a * d, âŸ¨âˆ i, x i ^ ai i, hai â–¸ SetLike.fintype_prod_pow_mem_graded hxdâŸ©,
        âŸ¨f ^ a, SetLike.pow_mem_graded a hfâŸ©, by use aâŸ© |
        (a : â„•) (ai : Î¹ â†’ â„•) (hai : âˆ‘ i, ai i * dx i = a * d) (_ : âˆ€ i, ai i â‰¤ d) } = âŠ¤ := by
  classical
  rw [â† top_le_iff]
  show âŠ¤ â‰¤ (Algebra.adjoin (ğ’œ 0) _).toSubmodule
  rw [â† HomogeneousLocalization.Away.span_monomial_eq_top ğ’œ f d hf Î¹
    x inferInstance hx dx hxd, Submodule.span_le]
  rintro _ âŸ¨a, ai, hai, rflâŸ©
  have Hâ‚€ : (a - âˆ‘ i : Î¹, dx i * (ai i / d)) * d = âˆ‘ k : Î¹, (ai k % d) â€¢ dx k := by
    rw [tsub_mul, â† hai]
    conv => enter [1, 1, 2, i]; rw [â† Nat.mod_add_div (ai i) d]
    simp_rw [add_mul, Finset.sum_add_distrib, mul_assoc, â† Finset.mul_sum, mul_comm d, mul_comm (_ / _)]
    simp only [add_tsub_cancel_right, smul_eq_mul]
  have H : mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨a * d, âŸ¨âˆ i, x i ^ ai i, hai â–¸ SetLike.fintype_prod_pow_mem_graded hxdâŸ©,
        âŸ¨f ^ a, SetLike.pow_mem_graded a hfâŸ©, by use aâŸ© =
      mk (ğ’œ := ğ’œ) (x := .powers f)
        âŸ¨(a - âˆ‘ i : Î¹, dx i * (ai i / d)) * d,
          âŸ¨âˆ i, x i ^ (ai i % d), Hâ‚€ â–¸ SetLike.fintype_prod_pow_mem_graded hxdâŸ©,
          âŸ¨f ^ (a - âˆ‘ i, dx i * (ai i / d)), SetLike.pow_mem_graded _ hfâŸ©, by exact âŸ¨_, rflâŸ©âŸ© *
      âˆ i, mk âŸ¨_, âŸ¨x i ^ d, SetLike.pow_mem_graded d (hxd i)âŸ©,
        âŸ¨f ^ dx i, by convert SetLike.pow_mem_graded (dx i) hf using 2; simpa using mul_comm _ _âŸ©,
        by exact âŸ¨_, rflâŸ©âŸ© ^ (ai i / d) := by
    apply (show Function.Injective (algebraMap (Away ğ’œ f) (Localization.Away f))
      from val_injective _)
    simp only [map_pow, map_prod, map_mul]
    simp only [HomogeneousLocalization.algebraMap_apply, val_mk,
      Localization.mk_pow, Localization.mk_prod, Localization.mk_mul,
      â† Finset.prod_mul_distrib, â† pow_add, â† pow_mul]
    congr
    Â· ext i
      congr
      exact Eq.symm (Nat.mod_add_div (ai i) d)
    Â· simp only [SubmonoidClass.mk_pow, SubmonoidClass.coe_finset_prod, â† pow_add, â† pow_mul,
        Finset.prod_pow_eq_pow_sum]
      rw [tsub_add_cancel_of_le]
      rw [â† mul_le_mul_iff_of_pos_right hd, â† hai, Finset.sum_mul]
      simp_rw [mul_comm (ai _), mul_assoc]
      gcongr
      exact Nat.div_mul_le_self (ai _) d
  rw [H, SetLike.mem_coe]
  apply (Algebra.adjoin (ğ’œ 0) _).mul_mem
  Â· apply Algebra.subset_adjoin
    refine âŸ¨a - âˆ‘ i : Î¹, dx i * (ai i / d), (ai Â· % d), Hâ‚€.symm, ?_, rflâŸ©
    exact fun i â†¦ (Nat.mod_lt _ hd).le
  apply prod_mem
  Â· rintro j -
    apply pow_mem
    apply Algebra.subset_adjoin
    refine âŸ¨dx j, Pi.single j d, ?_, ?_, ?_âŸ©
    Â· simp [Pi.single_apply, mul_comm]
    Â· aesop (add simp Pi.single_apply)
    ext
    simp [Pi.single_apply]

lemma HomogeneousLocalization.Away.finiteType [Algebra.FiniteType (ğ’œ 0) S]
    (f : S) (d : â„•) (hf : f âˆˆ ğ’œ d) (hd : 0 < d) :
    Algebra.FiniteType (ğ’œ 0) (Away ğ’œ f) := by
  constructor
  obtain âŸ¨Î¹, x, _, hx, hx'âŸ© := FG_by_homogeneous ğ’œ
  choose dx hdx hxd using hx'
  rw [â† HomogeneousLocalization.Away.adjoin_monomial_eq_top ğ’œ f d hf hd Î¹ x inferInstance hx dx hxd,
    Subalgebra.fg_def]
  refine âŸ¨_, ?_, rflâŸ©
  let b := âˆ‘ i, dx i
  let s : Set ((Fin (b + 1)) Ã— (Î¹ â†’ Fin (d + 1))) := { ai | âˆ‘ i, (ai.2 i).1 * dx i = ai.1 * d }
  let f : s â†’ Away ğ’œ f := fun ai â†¦ mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨ai.1.1 * d, âŸ¨âˆ i, x i ^ (ai.1.2 i).1,
        by convert SetLike.fintype_prod_pow_mem_graded hxd; exact ai.2.symmâŸ©,
        âŸ¨f ^ ai.1.1.1, SetLike.pow_mem_graded ai.1.1.1 hfâŸ©, by exact âŸ¨_, rflâŸ©âŸ©
  apply (Set.finite_range f).subset
  rintro _ âŸ¨a, ai, hai, hai', rflâŸ©
  refine âŸ¨âŸ¨âŸ¨âŸ¨a, ?_âŸ©, fun i â†¦ âŸ¨ai i, (hai' i).trans_lt d.lt_succ_selfâŸ©âŸ©, haiâŸ©, rflâŸ©
  rw [Nat.lt_succ, â† mul_le_mul_iff_of_pos_right hd, â† hai, Finset.sum_mul]
  simp_rw [mul_comm _ d]
  gcongr
  exact hai' _

lemma useful (n : â„•) : n = 0 âˆ¨ âˆƒ m, n = m + 1 := by
  cases n with
  | zero => tauto
  | succ n => tauto

theorem projective_implies_proper_aux
    (Î¹ : Type) [Fintype Î¹] (x : Î¹ â†’ S)
    (h2 : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = (âŠ¤ : Subalgebra (ğ’œ 0) S))
    (j : Î¹)
    (Ï† : Away ğ’œ (x j) â†’+* K)
    (d : Î¹ â†’ â„•)
    (hdi : âˆ€ i, 0 < d i)
    (hxdi : âˆ€ i, x i âˆˆ ğ’œ (d i)) :
    âˆƒ (xâ‚€ : S) (e : â„•) (he : 0 < e)
      (hâ‚€ : xâ‚€ âˆˆ ğ’œ e)
      (Ï†' : Away ğ’œ ((x j) * xâ‚€) â†’+* K),
      (Ï†'.comp (map2 ğ’œ hâ‚€ rfl) = Ï†) âˆ§
      Set.range (Ï†'.comp (map2 ğ’œ (hxdi j) (mul_comm (x j) xâ‚€))) âŠ† Set.range (algebraMap A K) := by
  classical
  let Ïˆ : (i : Î¹) â†’ ValuationRing.ValueGroup A K :=
    fun i â†¦ ValuationRing.valuation A K <| (Ï† (mk {
      deg := (d j) * d i
      num := âŸ¨x i ^ d j, SetLike.pow_mem_graded (d j) (hxdi i) âŸ©
      den := âŸ¨(x j)^(d i) , mul_comm (d j) (d i) â–¸ SetLike.pow_mem_graded (d i) ( hxdi j)âŸ©
      den_mem := âŸ¨_, rflâŸ©
    }))^ âˆ k in Finset.univ.erase i, d k
  have hÎ¹nonempty : Nonempty Î¹ := by exact Î¹_nonempty ğ’œ (hdi j) Î¹ x (hxdi j) Ï† h2
  have foo : (Finset.image Ïˆ Finset.univ).Nonempty := by rwa [Finset.image_nonempty, Finset.univ_nonempty_iff]
  set Kmax := Finset.max' (Finset.image Ïˆ Finset.univ) foo
  have : Kmax âˆˆ _ := Finset.max'_mem (Finset.image Ïˆ Finset.univ) foo
  simp only [Finset.mem_image, Finset.mem_univ, true_and] at this
  obtain âŸ¨i0, hi1âŸ© := this
  have hi0 : âˆ€ (j : Î¹), Ïˆ j â‰¤ Ïˆ i0 := by
    intro j
    rw [hi1]
    exact Finset.le_max' (Finset.image Ïˆ Finset.univ) (Ïˆ j) (by simp)
  use x i0, d i0, hdi i0, hxdi i0
  have hKmax : Kmax â‰  0 := by
    intro hKmax
    unfold Kmax at hKmax
    have : âˆ€ i : Î¹, Ïˆ i â‰¤ 0 := by
      intro i
      rw [â† hKmax]
      apply Finset.le_max'
      simp
    have this : âˆ€ i, Ïˆ i = 0 := by
      intro i
      specialize this i
      exact le_zero_iff.mp this
    unfold Ïˆ at this
    simp only [map_pow, pow_eq_zero_iff', map_eq_zero, ne_eq] at this
    specialize this j
    suffices Ï† 1 = 0 by
      simp only [map_one, one_ne_zero] at this
    convert this.1
    ext
    simp only [val_one, val_mk]
    symm
    convert Localization.mk_self _
    rfl
  have hKmax : 0 < Kmax := zero_lt_iff.mpr hKmax
  have foo := HomogeneousLocalization.Away.isLocalization_mul ğ’œ (x j) (x i0) (d j) (d i0)
    (hxdi j) (hxdi i0) (hdi _).ne' (hdi _).ne'
  letI := awayAlgebra ğ’œ (x j) (x i0) (d i0) (hxdi i0)
  have foounit : IsUnit (Ï† (mk { deg := d j * d i0,
                                 num := âŸ¨x i0 ^ d j, SetLike.pow_mem_graded (d j) (hxdi i0)âŸ©,
                                 den := âŸ¨x j ^ d i0, mul_comm (d j) (d i0) â–¸ SetLike.pow_mem_graded (d i0) ( hxdi j)âŸ©,
                                 den_mem := âŸ¨d i0, rflâŸ©})) := by
    unfold Ïˆ at hi1
    apply Ne.isUnit
    intro rid
    rw [rid] at hi1
    simp only [map_pow, map_zero] at hi1
    rw [zero_pow] at hi1
    Â· exact hKmax.ne' hi1.symm
    simp only [ne_eq, Finset.prod_eq_zero_iff, Finset.mem_erase, Finset.mem_univ, and_true,
      not_exists, not_and]
    intro k _ hk
    exact hdi k |>.ne' hk
  let Ï†' := @IsLocalization.Away.lift _ _ _ _ _ _ _ _ foo Ï† foounit
  have hÏ†' : âˆ€ s, Ï†' _ = _ := @IsLocalization.Away.AwayMap.lift_eq _ _ _ _ _ _ _ _ foo _ foounit
  have hÏ†'1 : âˆ€ (s : Away ğ’œ (x j)), Ï†' (map2 ğ’œ (hxdi i0) rfl s) = Ï† s := fun s â†¦ hÏ†' s
  use Ï†'
  use IsLocalization.Away.AwayMap.lift_comp ..
  rintro _ âŸ¨sx, rflâŸ©
  rw [Set.mem_range, â† ValuationRing.mem_integer_iff]
  rw [Valuation.mem_integer_iff]
  have := HomogeneousLocalization.Away.span_monomial_eq_top ğ’œ (x i0) (d i0) (hxdi i0) Î¹
    x inferInstance h2 d hxdi
  letI inst1 : Algebra (ğ’œ 0) (Away ğ’œ (x i0)) := inferInstance
  letI inst2 : Module (ğ’œ 0) (Away ğ’œ (x i0)) := Algebra.toModule
  have foo2 : sx âˆˆ (âŠ¤ : Submodule (ğ’œ 0) (Away ğ’œ (x i0))) := Submodule.mem_top
  rw [â† this] at foo2
  induction foo2 using Submodule.span_induction with
  | mem x1 h =>
    obtain âŸ¨a, ai, hai, rflâŸ© := h
    suffices (ValuationRing.valuation A K)
        (Ï† (mk {deg := a * d i0 * d j,
                num := âŸ¨(âˆ i : Î¹, x i ^ ai i) * (x i0) ^ (a * (d j - 1)), by
                  convert SetLike.mul_mem_graded
                    (SetLike.fintype_prod_pow_mem_graded (v := ai) (i := d) hxdi)
                    (SetLike.pow_mem_graded (a * (d j - 1)) (hxdi i0)) using 2
                  simp only [smul_eq_mul]
                  rw [hai]
                  have hdj : (d j â‰  0) := (hdi j).ne'
                  revert hdj
                  cases (d j)
                  Â· simp only [ne_eq, not_true_eq_false, mul_zero, zero_le, Nat.sub_eq_zero_of_le,
                    zero_mul, add_zero, zero_eq_mul, IsEmpty.forall_iff]
                  Â· intro _
                    simp only [add_tsub_cancel_right]
                    ring
                âŸ©,
                den := âŸ¨(x j) ^ (a * d i0), SetLike.pow_mem_graded (a * d i0) (hxdi j)âŸ©,
                den_mem := âŸ¨_, rflâŸ©}) /
          (Ï† (mk {deg := d j * d i0,
                  num := âŸ¨(x i0) ^ d j, SetLike.pow_mem_graded (d j) (hxdi i0)âŸ©,
                  den := âŸ¨(x j) ^ (d i0), by
                    have := SetLike.pow_mem_graded (d i0) (hxdi j)
                    convert this using 2
                    apply mul_commâŸ©,
                  den_mem := âŸ¨_, rflâŸ©})) ^ a) â‰¤ 1 by
      convert this
      rw [eq_div_iff <| by rw [â†isUnit_iff_ne_zero]; exact IsUnit.pow _ foounit]
      rw [â† hÏ†'1, â† hÏ†'1]
      simp only [RingHom.coe_comp, Function.comp_apply]
      rw [â† map_pow, â† map_mul]
      congr
      ext
      rw [val_mul]
      rw [val_map2_mk ğ’œ]
      simp only [val_pow]
      rw [val_map2_mk ğ’œ]
      rw [val_map2_mk ğ’œ]
      rw [Localization.mk_pow, Localization.mk_mul, Localization.mk_eq_mk_iff, Localization.r_iff_exists]
      use 1
      simp only [OneMemClass.coe_one, one_mul, SubmonoidClass.mk_pow, Submonoid.mk_mul_mk]
      obtain h | âŸ¨m, hmâŸ© := useful (d j)
      Â· exfalso
        exact (hdi j).ne' h
      rw [hm, Nat.add_sub_cancel]
      ring
    rw [map_divâ‚€]
    -- the below sorry: use foounit which says it's a unit in K and hence
    -- nonzero and hence its valuation is positive.
    rw [div_le_iffâ‚€ (by
      rw [Valuation.map_pow]
      apply pow_pos ((Valuation.pos_iff _).mpr (IsUnit.ne_zero foounit))
      ), one_mul]
    rw [â† pow_le_pow_iff_leftâ‚€ (n := d j * âˆ i, d i) zero_le' zero_le' <|
      (mul_pos (hdi j) (Finset.prod_pos (fun i _ => hdi i))).ne.symm]
    convert_to (âˆ i, Ïˆ i ^ (d i * ai i)) * Ïˆ i0 ^ (d i0 * a * (d j - 1)) â‰¤ _
    Â· simp only [Ïˆ, â† map_pow, â† map_prod, â† map_mul]
      congr 2
      apply (show Function.Injective (algebraMap (Away ğ’œ (x j)) (Localization.Away (x j)))
        from val_injective _)
      simp only [map_pow, map_prod, map_mul]
      simp only [HomogeneousLocalization.algebraMap_apply, val_mk,
        Localization.mk_pow, Localization.mk_prod, Localization.mk_mul]
      rw [Localization.mk_eq_mk_iff, Localization.r_iff_exists]
      use 1
      simp only [OneMemClass.coe_one, SubmonoidClass.mk_pow, â† pow_mul, Submonoid.coe_mul,
        SubmonoidClass.coe_finset_prod, one_mul]
      simp_rw [Finset.mul_prod_erase Finset.univ d (h := Finset.mem_univ _),
        mul_assoc, â† mul_assoc (Finset.prod ..),
        Finset.prod_erase_mul Finset.univ d (h := Finset.mem_univ _)]
      rw [Finset.prod_pow_eq_pow_sum, â† pow_add, mul_pow, â† Finset.prod_pow]
      simp_rw [â† pow_mul]
      congr 3
      Â· simp_rw [mul_assoc, â† Finset.mul_sum, mul_comm (d _) (ai _), hai]
        have : d j â‰  0 := (hdi j).ne'
        revert this
        cases d j
        Â· simp
        Â· intro _
          simp
          ring
      Â· ext i
        congr 1
        ring
      Â· ring
    Â· trans (âˆ i : Î¹, Ïˆ i0 ^ (d i * ai i)) * Ïˆ i0 ^ (d i0 * a * (d j - 1))
      Â· gcongr
        Â· exact zero_le'
        Â· exact hi0 _
      Â· rw [Finset.prod_pow_eq_pow_sum, â† pow_add]
        convert_to (Ïˆ i0) ^ (d i0 * a * d j) â‰¤ _
        Â· congr 1
          simp_rw [mul_comm (d _) (ai _), hai]
          have : d j â‰  0 := (hdi j).ne'
          revert this
          cases d j
          Â· simp
          Â· intro _
            simp
            ring
        Â· apply le_of_eq
          simp only [Ïˆ, â† map_pow, â† map_prod, â† map_mul]
          congr 2
          rw [â† pow_mul, mul_assoc, â† mul_assoc,
            Finset.prod_erase_mul Finset.univ d (h := Finset.mem_univ _),
            mul_left_comm, pow_mul]
          congr 1
          rw [mul_comm]
  | zero => simp
  | add x y hx hy hhx hhy =>
    simp only [RingHom.coe_comp, Function.comp_apply, map_add, ge_iff_le]
    transitivity
    refine Valuation.map_add (ValuationRing.valuation A K) _ _
    rw [sup_le_iff]
    exact âŸ¨hhx, hhyâŸ©
  | smul a x hx _ =>
    -- a â€¢ x is (image of a in K) * x, which is (image of a in A) * x,
    -- and stuff in A has valuation <= 1. This involves a tricky diagram
    -- chase in practice though. Justus was thinking about this sorry
    rw [Algebra.smul_def]
    -- Kevin is working on this sorry
    sorry

end statement
