import Mathlib
import DurhamAlgGeom2024.Tutorial.Â«06SeparatedÂ»
section missing_instance
/-

Andrew's definition of the algebra structure on `HomogeneousLocalization ğ’œ S`.

-/
open HomogeneousLocalization in
instance {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    Algebra R (HomogeneousLocalization ğ’œ S) :=
  ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)).toAlgebra

@[simp]
lemma HomogeneousLocalization.algebraMap_eq
  {R A Î¹ : Type*} [CommRing R] [CommRing A] [Algebra R A] [DecidableEq Î¹]
  [AddCommMonoid Î¹] (ğ’œ : Î¹ â†’ Submodule R A) [GradedAlgebra ğ’œ] (S : Submonoid A) :
    algebraMap R (HomogeneousLocalization ğ’œ S) = ((fromZeroRingHom ğ’œ S).comp (algebraMap _ _)) := rfl

end missing_instance

noncomputable section statement

variable {Râ‚€ S : Type}
variable [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S]
variable (ğ’œ : â„• â†’ Submodule Râ‚€ S) [GradedAlgebra ğ’œ]

instance : Algebra (ğ’œ 0) S := (SetLike.GradeZero.subalgebra ğ’œ).toAlgebra
variable [Algebra.FiniteType (ğ’œ 0) S]

/-

## Generation of S by homogeneous elements

By definition `S = â¨áµ¢ (ğ’œ i)` is a graded ring (graded by `â„•`) and
in particular `S` is an `ğ’œ 0`-algebra.

By assumption `S` is finitely-generated `ğ’œ 0`-algebra.

What we next claim is that `S` is generated by finitely many *homogeneous*
elements of `S`.

-/

-- S is finitely-generated over ğ’œ 0
example : âˆƒ (F : Set S),
    (F.Finite) âˆ§ (Algebra.adjoin (ğ’œ 0) F = âŠ¤) := by
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  exact âŸ¨F, F.finite_toSet, hFâŸ©

-- But we need homogeneous generators.
-- This preliminary version gives homogeneous generators
-- but allows generators in degree 0
theorem FG_by_homogeneousâ‚€ : âˆƒ (Î¹â‚€ : Type) (x : Î¹â‚€ â†’ S) (_ : Fintype Î¹â‚€),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹â‚€, âˆƒ n : â„•, x i âˆˆ ğ’œ n) := by
  classical
  -- S is finitely-generated
  obtain âŸ¨F, hFâŸ© := Algebra.FiniteType.out (R := ğ’œ 0) (A := S)
  -- Î¹â‚€ is pairs (s,n) such that s âˆˆ F and sâ‚™ â‰  0
  let Î¹â‚€ := Î£ (x : F), (DirectSum.decompose ğ’œ x.1).support
  -- x(s,n) is sâ‚™
  let x (i : Î¹â‚€) : S := ((DirectSum.decompose ğ’œ) i.1 i.2).1
  -- This should work
  refine âŸ¨Î¹â‚€, x, inferInstance, ?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† hF]
    apply Algebra.adjoin_le
    -- STP that if s âˆˆ F then s âˆˆ ğ’œâ‚€[tâ‚˜] for t running through F
    intro s hs
    -- Well s = âˆ‘â‚™ sâ‚™
    rw [â† DirectSum.sum_support_decompose ğ’œ s]
    -- so it suffices that âˆ€ n, sâ‚™ âˆˆ ğ’œâ‚€[tâ‚˜]
    apply sum_mem
    intro n hn
    -- so it suffices that sâ‚™ is one of the tâ‚˜
    apply Algebra.subset_adjoin
    -- but this is obvious
    use âŸ¨âŸ¨s, hsâŸ©, n, hnâŸ©
  Â· rintro âŸ¨f, nfâŸ©
    use nf
    exact ((DirectSum.decompose ğ’œ) f nf).2

theorem FG_by_homogeneous : âˆƒ (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹),
    (Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) âˆ§
    (âˆ€ i : Î¹, âˆƒ n : â„•, 0 < n âˆ§ x i âˆˆ ğ’œ n) := by
  obtain âŸ¨Î¹â‚€, x, _, h1, h2âŸ© := FG_by_homogeneousâ‚€ ğ’œ
  choose n hn using h2
  use {i : Î¹â‚€ // 0 < n i}, fun j â†¦ x j.1, inferInstance
  refine âŸ¨?_, ?_âŸ©
  Â· rw [â† top_le_iff, â† h1]
    apply Algebra.adjoin_le
    rintro s âŸ¨i, rflâŸ©
    by_cases hi : 0 < n i
    Â· apply Algebra.subset_adjoin
      use âŸ¨i, hiâŸ©
    Â· have hi0 : n i = 0 := by omega
      exact Subalgebra.algebraMap_mem
        (Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range fun (j : {i : Î¹â‚€ // 0 < n i}) â†¦ x j)) âŸ¨x i, hi0 â–¸ hn iâŸ©
  Â· rintro âŸ¨i, hiâŸ©
    use n i, hi
    apply hn

open HomogeneousLocalization

/-

## S_{(f)} is an ğ’œâ‚€-algebra

Although S_{(f)} isn't an S-algebra (because S has
stuff in degree not zero but S_{(f)} is only degree 0 stuff)

-/

variable {d : â„•}
variable {f : S} (hf : f âˆˆ ğ’œ d)

--#synth Algebra (ğ’œ 0) (Away ğ’œ f)

variable {A : Type} [CommRing A] [IsDomain A] [ValuationRing A]
variable {K : Type} [Field K] [Algebra A K] [IsFractionRing A K]

/-
The diagram in the question

                  Ï†
              K <--- S(f)
              /\      /\
     canonical|       |canonical
              |       |
              A <---- ğ’œâ‚€
                  Ï†â‚€
-/

variable (Ï†â‚€ : (ğ’œ 0) â†’+* A)
variable (Ï† : (Away ğ’œ f) â†’+* K)
variable (hcomm : (algebraMap A K).comp Ï†â‚€ = Ï†.comp (fromZeroRingHom ğ’œ _))

/-
projective_implies_proper_aux {Râ‚€ S : Type} [CommRing Râ‚€] [CommRing S] [Algebra Râ‚€ S] (ğ’œ : â„• â†’ Submodule Râ‚€ S)
  [GradedAlgebra ğ’œ] [Algebra.FiniteType (â†¥(ğ’œ 0)) S] {d : â„•} {f : S} (hf : f âˆˆ ğ’œ d) {A : Type} [CommRing A] [IsDomain A]
  [ValuationRing A] {K : Type} [Field K] [Algebra A K] [IsFractionRing A K] (Ï† : Away ğ’œ f â†’+* K) (hd : 0 < d) :
  âˆƒ xâ‚€ e,
    âˆƒ (_ : 0 < e) (hâ‚€ : xâ‚€ âˆˆ ğ’œ e),
      âˆƒ Ï†', Ï†'.comp (map2 ğ’œ hâ‚€ â‹¯) = Ï† âˆ§ Set.range â‡‘(Ï†'.comp (map2 ğ’œ hf â‹¯)) âŠ† Set.range â‡‘(algebraMap A K)
-/

omit [GradedAlgebra ğ’œ] [Algebra.FiniteType (â†¥(ğ’œ 0)) S] in
lemma away_zero_subsingleton : Subsingleton (Away ğ’œ 0) := by
  apply HomogeneousLocalization.subsingleton
  use 1
  simp

omit [Algebra.FiniteType (â†¥(ğ’œ 0)) S] in
lemma f_ne_zero_of_away_ringHom (Ï† : Away ğ’œ f â†’+* K) : f â‰  0 := by
  rintro rfl
  have : Subsingleton (Away ğ’œ 0) :=
    away_zero_subsingleton ğ’œ
  have : Subsingleton K := RingHom.codomain_trivial Ï†
  have : Nontrivial K := CommGroupWithZero.toNontrivial
  exact false_of_nontrivial_of_subsingleton K

omit [Algebra.FiniteType (â†¥(ğ’œ 0)) S] in
lemma Î¹_nonempty (hd : 0 < d) (Î¹ : Type) (x : Î¹ â†’ S)
    {f : S} (hf : f âˆˆ ğ’œ d) (Ï† : Away ğ’œ f â†’+* K)
    (hÎ¹ : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = âŠ¤) : Nonempty Î¹ := by
  suffices Â¬ IsEmpty Î¹ by exact not_isEmpty_iff.mp this
  intro hempty
  have hf0 : f â‰  0 := by exact f_ne_zero_of_away_ringHom ğ’œ Ï†
  have := Algebra.adjoin_empty (ğ’œ 0) S
  have range_empty : Set.range x = âˆ… := by
    rw [Set.eq_empty_iff_forall_not_mem]
    intro s âŸ¨i, hiâŸ©
    exact IsEmpty.false i
  rw [range_empty, this] at hÎ¹
  have hf2 : f âˆˆ (âŠ¤ : Subalgebra (ğ’œ 0) S) := by exact trivial
  rw [â† hÎ¹] at hf2
  suffices d = 0 by omega
  refine DirectSum.degree_eq_of_mem_mem ğ’œ hf ?_ hf0
  rw [Algebra.mem_bot] at hf2
  obtain âŸ¨âŸ¨g, hg1âŸ©, hgâŸ© := hf2
  rw [â† hg]
  exact hg1

instance (x : Submonoid S) : Algebra (ğ’œ 0) (HomogeneousLocalization ğ’œ x) :=
  (HomogeneousLocalization.fromZeroRingHom ğ’œ x).toAlgebra

theorem SetLike.prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R]
    [AddCommMonoid Î¹] {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    {F : Finset Îº} (hF : âˆ€ k âˆˆ F, g k âˆˆ A (i k)) : âˆ k âˆˆ F, g k âˆˆ A (âˆ‘ k âˆˆ F, i k) := by
  classical
  induction F using Finset.induction_on
  Â· simp [GradedOne.one_mem]
  Â· case insert j F' hF2 h3 =>
    rw [Finset.prod_insert hF2, Finset.sum_insert hF2]
    apply SetLike.mul_mem_graded (hF j <| Finset.mem_insert_self j F')
    apply h3
    intro k hk
    apply hF k
    exact Finset.mem_insert_of_mem hk

theorem SetLike.fintype_prod_mem_graded {Î¹ R S : Type*} [SetLike S R] [CommMonoid R] [AddCommMonoid Î¹]
    {A : Î¹ â†’ S} [SetLike.GradedMonoid A] {Îº : Type*} [Fintype Îº] â¦ƒi : Îº â†’ Î¹â¦„ {g : Îº â†’ R}
    (hF : âˆ€ k, g k âˆˆ A (i k)) : âˆ k, g k âˆˆ A (âˆ‘ k, i k) :=
  prod_mem_graded fun k _ â†¦ hF k

open HomogeneousLocalization in
theorem Span_monomial_eq_top (f : S) (d : â„•) (hf : f âˆˆ ğ’œ d) (Î¹ : Type) (x : Î¹ â†’ S) (_ : Fintype Î¹)
    (hx : Algebra.adjoin (ğ’œ 0) (Set.range x) = âŠ¤) (dx : Î¹â†’ â„• ) (hxd : âˆ€i, x i âˆˆ ğ’œ (dx i)) :
    Submodule.span (ğ’œ 0) { mk (ğ’œ := ğ’œ) (x := .powers f)
      âŸ¨a * d, âŸ¨âˆ i, x i ^ ai i, by
        rw [â† hai]
        apply SetLike.fintype_prod_mem_graded
        exact fun i â†¦ SetLike.pow_mem_graded _ (hxd i)âŸ©, âŸ¨f ^ a, SetLike.pow_mem_graded a hfâŸ©, by use aâŸ© |
        (a : â„•) (ai : Î¹ â†’ â„•) (hai : âˆ‘ i, ai i * dx i = a * d) } = âŠ¤ := by
  sorry

omit f Ï† [Algebra.FiniteType (â†¥(ğ’œ 0)) S] in
theorem projective_implies_proper_aux
    (Î¹ : Type) [Fintype Î¹] (x : Î¹ â†’ S)
    (h2 : Algebra.adjoin (â†¥(ğ’œ 0)) (Set.range x) = (âŠ¤ : Subalgebra (ğ’œ 0) S))
    (j : Î¹)
    (Ï† : Away ğ’œ (x j) â†’+* K)
    (d : Î¹ â†’ â„•)
    (hdi : âˆ€ i, 0 < d i)
    (hxdi : âˆ€ i, x i âˆˆ ğ’œ (d i))
    :
    âˆƒ (xâ‚€ : S) (e : â„•) (he : 0 < e)
    (hâ‚€ : xâ‚€ âˆˆ ğ’œ e)
    (Ï†' : Away ğ’œ ((x j) * xâ‚€) â†’+* K),
    (Ï†'.comp (map2 ğ’œ hâ‚€ rfl) = Ï†) âˆ§
    Set.range (Ï†'.comp (map2 ğ’œ (hxdi j) (mul_comm (x j) xâ‚€))) âŠ† Set.range (algebraMap A K) := by
  classical
  let Ïˆ: (i : Î¹) â†’ ValuationRing.ValueGroup A K :=
    fun i â†¦ ValuationRing.valuation A K <| (Ï† (mk {
      deg := (d j) * d i
      num := âŸ¨x i ^ d j, SetLike.pow_mem_graded (d j) (hxdi i) âŸ©
      den := âŸ¨(x j)^(d i) , mul_comm (d j) (d i) â–¸ SetLike.pow_mem_graded (d i) ( hxdi j)âŸ©
      den_mem := âŸ¨_, rflâŸ©
    }))^ âˆ k in Finset.univ.erase i, d k
  have hÎ¹nonempty : Nonempty Î¹ := by exact Î¹_nonempty ğ’œ (hdi j) Î¹ x (hxdi j) Ï† h2
  have foo : (Finset.image Ïˆ Finset.univ).Nonempty := by rwa [Finset.image_nonempty, Finset.univ_nonempty_iff]
  set Kmax := Finset.max' (Finset.image Ïˆ Finset.univ) foo
  have : Kmax âˆˆ _ := Finset.max'_mem (Finset.image Ïˆ Finset.univ) foo
  simp only [Finset.mem_image, Finset.mem_univ, true_and] at this
  obtain âŸ¨i0, hi0âŸ© := this
  have hi0 : âˆ€ (j : Î¹), Ïˆ j â‰¤ Ïˆ i0 := by
    intro j
    rw [hi0]
    exact Finset.le_max' (Finset.image Ïˆ Finset.univ) (Ïˆ j) (by simp)
  use x i0, d i0, hdi i0, hxdi i0
  have hKmax : Kmax â‰  0 := by
    intro hKmax
    unfold Kmax at hKmax
    have : âˆ€ i : Î¹, Ïˆ i â‰¤ 0 := by
      intro i
      rw [â† hKmax]
      apply Finset.le_max'
      simp
    have this : âˆ€ i, Ïˆ i = 0 := by
      intro i
      specialize this i
      exact le_zero_iff.mp this
    unfold Ïˆ at this
    simp only [map_pow, pow_eq_zero_iff', map_eq_zero, ne_eq] at this
    specialize this j
    suffices Ï† 1 = 0 by
      simp only [map_one, one_ne_zero] at this
    convert this.1
    ext
    simp only [val_one, val_mk]
    symm
    convert Localization.mk_self _
    rfl
  have hKmax : 0 < Kmax := zero_lt_iff.mpr hKmax
  sorry

end statement
